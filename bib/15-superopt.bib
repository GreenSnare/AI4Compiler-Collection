@inproceedings{schkufza2013stochastic,
  title={Stochastic superoptimization},
  author={Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
  booktitle={Proceedings of the eighteenth international conference on Architectural support for programming languages and operating systems},
  pages={305--316},
  year={2013},
      link={https://dl.acm.org/doi/10.1145/2451116.2451150},
    abstract = {We formulate the loop-free binary superoptimization task as a stochastic search problem. The competing constraints of transformation correctness and performance improvement are encoded as terms in a cost function, and a Markov Chain Monte Carlo sampler is used to rapidly explore the space of all possible programs to find one that is an optimization of a given target program. Although our method sacrifices completeness, the scope of programs we are able to consider, and the resulting quality of the programs that we produce, far exceed those of existing superoptimizers. Beginning from binaries compiled by llvm -O0 for 64-bit x86, our prototype implementation, STOKE, is able to produce programs which either match or outperform the code produced by gcc -O3, icc -O3, and in some cases, expert handwritten assembly.},
    keywords = {superopt,RL,Assembly},
}

@article{schkufza2014stochastic,
  title={Stochastic optimization of floating-point programs with tunable precision},
  author={Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
  journal={ACM SIGPLAN Notices},
  volume={49},
  number={6},
  pages={53--64},
  year={2014},
  publisher={ACM New York, NY, USA},
  link = {https://dl.acm.org/doi/abs/10.1145/2666356.2594302},
  abstract = {The aggressive optimization of floating-point computations is an important problem in high-performance computing. Unfortunately, floating-point instruction sets have complicated semantics that often force compilers to preserve programs as written. We present a method that treats floating-point optimization as a stochastic search problem. We demonstrate the ability to generate reduced precision implementations of Intel's handwritten C numeric library which are up to 6 times faster than the original code, and achieve end-to-end speedups of over 30% on a direct numeric simulation and a ray tracer by optimizing kernels that can tolerate a loss of precision while still remaining correct. Because these optimizations are mostly not amenable to formal verification using the current state of the art, we present a stochastic search technique for characterizing maximum error. The technique comes with an asymptotic guarantee and provides strong evidence of correctness.},
  keywords = {},
}

@article{sharma2015conditionally,
  title={Conditionally correct superoptimization},
  author={Sharma, Rahul and Schkufza, Eric and Churchill, Berkeley and Aiken, Alex},
  journal={ACM SIGPLAN Notices},
  volume={50},
  number={10},
  pages={147--162},
  year={2015},
  publisher={ACM New York, NY, USA},
  link = {https://dl.acm.org/doi/abs/10.1145/2858965.2814278},
  abstract = {The aggressive optimization of heavily used kernels is an important problem in high-performance computing. However, both general purpose compilers and highly specialized tools such as superoptimizers often do not have sufficient static knowledge of restrictions on program inputs that could be exploited to produce the very best code. For many applications, the best possible code is conditionally correct: the optimized kernel is equal to the code that it replaces only under certain preconditions on the kernel's inputs. The main technical challenge in producing conditionally correct optimizations is in obtaining non-trivial and useful conditions and proving conditional equivalence formally in the presence of loops. We combine abstract interpretation, decision procedures, and testing to yield a verification strategy that can address both of these problems. This approach yields a superoptimizer for x86 that in our experiments produces binaries that are often multiple times faster than those produced by production compilers.},
}

@article{schkufza2016stochastic,
  title={Stochastic program optimization},
  author={Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
  journal={Communications of the ACM},
  volume={59},
  number={2},
  pages={114--122},
  year={2016},
  publisher={ACM New York, NY, USA},
  link = {https://dl.acm.org/doi/abs/10.1145/2863701},
  abstract = {The optimization of short sequences of loop-free, fixed-point assembly code sequences is an important problem in high-performance computing. However, the competing constraints of transformation correctness and performance improvement often force even special purpose compilers to produce sub-optimal code. We show that by encoding these constraints as terms in a cost function, and using a Markov Chain Monte Carlo sampler to rapidly explore the space of all possible code sequences, we are able to generate aggressively optimized versions of a given target code sequence. Beginning from binaries compiled by 11vm --O0, we are able to produce provably correct code sequences that either match or outperform the code produced by qcc --O3, icc --O3, and in some cases expert handwritten assembly.},
  keywords = {HPC},
}

@article{churchill2017sound,
  title={Sound loop superoptimization for google native client},
  author={Churchill, Berkeley and Sharma, Rahul and Bastien, JF and Aiken, Alex},
  journal={ACM SIGPLAN Notices},
  volume={52},
  number={4},
  pages={313--326},
  year={2017},
  publisher={ACM New York, NY, USA},
  link = {https://dl.acm.org/doi/abs/10.1145/3093336.3037754},
  abstract = {Software fault isolation (SFI) is an important technique for the construction of secure operating systems, web browsers, and other extensible software. We demonstrate that superoptimization can dramatically improve the performance of Google Native Client, a SFI system that ships inside the Google Chrome Browser. Key to our results are new techniques for superoptimization of loops: we propose a new architecture for superoptimization tools that incorporates both a fully sound verification technique to ensure correctness and a bounded verification technique to guide the search to optimized code. In our evaluation we optimize 13 libc string functions, formally verify the correctness of the optimizations and report a median and average speedup of 25% over the libraries shipped by Google.},
  keywords = {loop},
}

@inproceedings{dasgupta2019complete,
  title={A complete formal semantics of x86-64 user-level instruction set architecture},
  author={Dasgupta, Sandeep and Park, Daejun and Kasampalis, Theodoros and Adve, Vikram S and Ro{\c{s}}u, Grigore},
  booktitle={Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
  pages={1133--1148},
  year={2019},
  link = {https://dl.acm.org/doi/abs/10.1145/3314221.3314601},
  abstract = {We present the most complete and thoroughly tested formal semantics of x86-64 to date. Our semantics faithfully formalizes all the non-deprecated, sequential user-level instructions of the x86-64 Haswell instruction set architecture. This totals 3155 instruction variants, corresponding to 774 mnemonics. The semantics is fully executable and has been tested against more than 7,000 instruction-level test cases and the GCC torture test suite. This extensive testing paid off, revealing bugs in both the x86-64 reference manual and other existing semantics. We also illustrate potential applications of our semantics in different formal analyses, and discuss how it can be useful for processor verification.},
  keywords = {X86},
}