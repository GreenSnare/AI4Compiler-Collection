@inproceedings{mosaner2022machine,
  title={Machine-Learning-Based Self-Optimizing Compiler Heuristics✱},
  author={Mosaner, Raphael and Leopoldseder, David and Kisling, Wolfgang and Stadler, Lukas and M{\"o}ssenb{\"o}ck, Hanspeter},
  booktitle={Proceedings of the 19th International Conference on Managed Programming Languages and Runtimes},
  pages={98--111},
  year={2022},
    abstract={Compiler optimizations are often based on hand-crafted heuristics to guide the optimization process. These heuristics are designed to benefit the average program and are otherwise static or only customized by profiling information. We propose machine-learning-based self-optimizing compiler heuristics, a novel approach for fitting optimization decisions in a dynamic compiler to specific environments. This is done by updating a machine learning model with extracted performance data at run time. Related work—which primarily targets static compilers—has already shown that machine learning can outperform hand-crafted heuristics. Our approach is specifically designed for dynamic compilation and uses concepts such as deoptimization for transparently switching between generating data and performing machine learning decisions in single program runs. We implemented our approach in the GraalVM, a high-performance production VM for dynamic compilation. When evaluating our approach by replacing loop peeling heuristics with learned models we encountered speedups larger than 30% for several benchmarks and only few slowdowns of up to 7%.},
    link = {https://dl.acm.org/doi/abs/10.1145/3546918.3546921},
    keywords = {GraalVM},
}

@inproceedings{jayasena2015auto,
  title={Auto-tuning the java virtual machine},
  author={Jayasena, Sanath and Fernando, Milinda and Rusira, Tharindu and Perera, Chalitha and Philips, Chamara},
  booktitle={2015 IEEE International Parallel and Distributed Processing Symposium Workshop},
  pages={1261--1270},
  year={2015},
  organization={IEEE},
  link = {https://ieeexplore.ieee.org/abstract/document/7284456},
  abstract = {We address the problem of tuning the performance of the Java Virtual Machine (JVM) with run-time flags (parameters). We use the Hot Spot JVM in our study. As the Hot Spot JVM comes with over 600 flags to choose from, selecting a subset manually to maximize performance is infeasible. In prior work, the potential performance improvement is limited by the fact that only a subset of the tunable flags are tuned. We adopt a different approach and present the Hot Spot Auto-tuner which considers the entire JVM and the effect of all the flags. To the best of our knowledge, ours is the first auto-tuner for optimizing the performance of the JVM as a whole. We organize the JVM flags into a tree structure by building a flag-hierarchy, which helps us to resolve dependencies on aspects of the JVM such as garbage collector algorithms and JIT compilation, and helps to reduce the configuration search-space. Experiments with the SPECjvm2008 and DaCapo benchmarks show that we could optimize the Hot Spot JVM with significant speedup, 16 SPECjvm2008 startup programs were improved by an average of 19% with three of them improved dramatically by 63%, 51% and 32% within a maximum tuning time of 200 minutes for each. Based on a minimum tuning time of 200 minutes, average performance improvement for 13 DaCapo benchmark programs is 26% with 42% being the maximum improvement.},
  keywords = {JIT,SPEC,JVM},
}

@inproceedings{canales2021optimization,
  title={Optimization of java virtual machine flags using feature model and genetic algorithm},
  author={Canales, Felipe and Hecht, Geoffrey and Bergel, Alexandre},
  booktitle={Companion of the ACM/SPEC International Conference on Performance Engineering},
  pages={183--186},
  year={2021},
  link = {https://dl.acm.org/doi/abs/10.1145/3447545.3451177},
  keywords = {JVM,GA},
  abstract = {Optimizing the Java Virtual Machine (JVM) options in order to get the best performance out of a program for production is a challenging and time-consuming task. HotSpot, the Oracle's open-source Java VM implementation offers more than 500 options, called flags, that can be used to tune the JVM's compiler, garbage collector (GC), heap size and much more. In addition to being numerous, these flags are sometimes poorly documented and create a need of benchmarking to ensure that the flags and their associated values deliver the best performance and stability for a particular program to execute. Auto-tuning approaches have already been proposed in order to mitigate this burden. However, in spite of increasingly sophisticated search techniques allowing for powerful optimizations, these approaches take little account of the underlying complexities of JVM flags. Indeed, dependencies and incompatibilities between flags are non-trivial to express, which if not taken into account may lead to invalid or spurious flag configurations that should not be considered by the auto-tuner. In this paper, we propose a novel model, inspired by the feature model used in Software Product Line, which takes the complexity of JVM's flags into account. We then demonstrate the usefulness of this model, using it as an input of a Genetic Algorithm (GA) to optimize the execution times of DaCapo Benchmarks.},
}